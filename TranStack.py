#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from matplotlib.widgets import Button, TextBox
import ipywidgets as widgets
from scipy.interpolate import interp1d
import wget
import platform



"""

    Config Variables (wavelengh range and globals)
    
"""
# text outputs to console
verbose = False 

# set working directory
defaultSubDir = "TestStack"


# Spectral range over which to work
wavelength_min = 0.2 # 0.5 um
wavelength_1um = 1
wavelength_max = 1 # 20 um

x_off = 0.2
x_h = 0.13

y_off = 0.05
y_h = 0.05


### DO NOT EDIT ###

wavelength_range = np.linspace(wavelength_min,wavelength_max, num=int((wavelength_max-wavelength_min)*10000))
transmission = np.ones(len(wavelength_range))
Filters = {}


####    FUNCTIONS AND CLASSES    ####

"""
getFilDir - change the working directory to one containing the csv files desired by the user:
"""
def goToFilDir():
    if(platform.system()=="Windows") :
        import win32gui
        from win32com.shell import shell, shellcon
        
        mydocs_pidl = shell.SHGetFolderLocation (0, shellcon.CSIDL_PERSONAL, 0, 0)
        pidl, display_name, image_list = shell.SHBrowseForFolder (
          win32gui.GetDesktopWindow (),
          mydocs_pidl,
          "Select a transmission curve file or folder",
          shellcon.BIF_BROWSEINCLUDEFILES,
          None,
          None
        )
        
        if (pidl, display_name, image_list) == (None, None, None):
          print("Nothing selected, using default")
          directory = os.path.join(os.getcwd(),defaultSubDir)
        else:
          directory = shell.SHGetPathFromIDList (pidl)
    else:
        tries = 5
        directory=""
        while(tries>0 and not os.path.isdir(directory)):
            directory = str(input("enter the directory of the filter curve files"))
        if(not os.path.isdir(directory)):
            directory = os.path.join(os.getcwd(),defaultSubDir)
    print("Switcheng To ", directory)
    os.chdir(directory)
""" 
    COUNTER : This class in a linkable iterator 
    for tracking the number of a given filter in the stack 
    and incrimenting and decrimenting it using linked matplotlib widgets
"""
class Counter(widgets.DOMWidget):
    value = 0
    def up(self,*args):
        self.value += 1
        update()
    def down(self,*args):
        self.value -= 1 if self.value > 0 else 0
        update()


"""
Optical Curve generates an interpolator from a csv file of wavelength transimission values
"""
def optical_curve(file):
    global verbose
    data = pd.read_csv(file, delimiter=',')
    data.columns = data.columns.str.strip()
    try:
        wavey = [col for col in data.columns if("wave" in col.lower()) ]
        wavelength = (data[wavey[0]])
    except:
        print("\n\n __ERROR__ \n Wavelength Data not found for file: {} \n please check data headings".format(file))
        return(-1)
    try:
        transmission = abs(data["transmission"])
    except:
        print("\n\n __ERROR__ \n Transmission Data not found for file: {} \n please check data headings".format(file))
        return(-1)
    if max(wavelength)>100:
        wavelength=wavelength/1000
        if verbose:
            print("Wavelength data in File {} appears to be in nm (max(w)>10), upscaling ... ".format(file))
    if max(transmission)>1:            
        transmission=transmission/100
        if verbose:
            print("The transmission data in File {} appears to be in percent, downscaling ... ".format(file))
    f2 = interp1d(wavelength, transmission, kind='cubic',bounds_error=False,fill_value=0.0001)
    if verbose:
        print("interpolation generated for {}".format(file))
    return f2



"""NOT IN USE """
def csvFromXl(xlfile):
    csvfile = pd.read_excel(xlfile).to_csv
    return(csvfile)


"""
Add Curve form file adds an interpolated transmission curve for the file (generated by optival curve) to the dictionary of filters
"""
def add_curve_from_file(file):
    global Filters
    global wavelength_range
    
    name = file.split('.')[0]
    nameST = "{}".format(name)
    if verbose:
        print("\n Found Filter {} \n at {}".format(nameST,file))    
    
    if file.endswith(".xls"):
        """NOT IN USE """
        file = csvFromXl(file)    
      
    func = optical_curve(file)
    if func != -1:     
        Filters.update({nameST:func(wavelength_range)})
    return()


"""add_curve_from_URL - NOT IN USE """
def add_curve_from_url(url):
    if type(url)!=str:
        print("getURL expects a string, got a {}".format(type(url)))
        return(-1)
    else:
        try:
            file = wget.download(url)
        except:
            print("wget download failed please check URL")
            return(-1)
        if file.endswith(".xls") or file.endswith(".csv"):
            return(add_curve_from_file(file))
        else:
            print("File is not a recognised type")
            return(-1)
    pd.read_excel()

"""
recalc - recalculates the transmission of the whole stack based on the counters assigned to each filter
"""
def recalc(WR, Filters, Coeffs):
    Trans = np.ones_like(WR)
    if len(Filters)==len(Coeffs):
        for ind, Filter in enumerate(Filters):
            Trans=Trans*(Filters[Filter]**Coeffs[ind].value)
    return(Trans)

"""
update refreshes the plotted graph to reflec any changes
"""
def update(*args): 
    global stacks
    for stack in stacks:
        stack["line"].set_ydata(recalc(wavelength_range, Filters, stack["coeffs"]))
        stack["line"].set_label(stack["name"].text)
        for ind, button in enumerate(stack["buttons"][::2]):
            button.label.set_text("remove [{}]".format(stack["coeffs"][ind].value))
    axMain.relim()
    axMain.set_ybound(upper=1)
    axMain.autoscale_view()
    axMain.legend()
    figMain.canvas.draw_idle()

"""
log - sets Y-Scale to logarithmic
"""
def log(*args): 
    print("log")
    axMain.set_yscale('log')
    update()
    return()
    
"""
lin - sets Y-Scale to linear
"""
def lin(*args):
    print("lin")
    axMain.set_yscale('linear')
    update()
    return()
    
"""
Saveline - Saves the line data as a csv named according to the stack name
"""
def Saveline(event):
    global stacks
    global wavelength_range
    def oncanvas(stack):
        return(event.canvas==stack["fig"].canvas)    
    def offcanvas(stack):
        return(event.canvas!=stack["fig"].canvas)    
    try:
        mystack = list(filter(oncanvas,stacks))[0]
    except():
        print("MAJOR ERROR button is not connected to a stack canvas \n I thought this an unreachable state and therefore cannot be trusted to advise!\n")
        return()
    name = mystack["name"]
    if verbose:print("Saving csv data for {}".format(name.text))
    
    data = np.transpose(mystack["line"].get_data())
    
    np.savetxt("{}.csv".format(name.text),data,delimiter=',',newline='\n',header='wavelength,transmission')

    return()

"""
Remstack - deletes the line and gui for the stack.
"""
def Remstack(event):
    global stacks
    def oncanvas(stack):
        return(event.canvas==stack["fig"].canvas)    
    def offcanvas(stack):
        return(event.canvas!=stack["fig"].canvas)
    try:
        mystack = list(filter(oncanvas,stacks))[0]
        stacks = list(filter(offcanvas,stacks))
    except():
        print("MAJOR ERROR button is not connected to a stack canvas \n I thought this an unreachable state and therefore cannot be trusted to advise!\n")
        return()
    name = mystack["name"]
    if verbose:print("User Requested Close Stack:  {}".format(name.text))
    plt.close(mystack["fig"])
    mystack["line"].remove()
    del(mystack)
    update()
    
    
    return()


"""
addtack - adds a new line to the plot and opens the associated GUI
"""
def addStack(*args):
    global stacks
    global axMain
    numStack = len(stacks)
    stacks.append({})
    stacks[numStack] = {"buttons":[]}
    stacks[numStack].update({"coeffs":[Counter() for _ in Filters]})

    axcolor = 'lightgoldenrodyellow'

    stackfig, stackax = plt.subplots()
    listheight =  len(Filters)*y_h #+y_off*2
    stackfig.set_figheight(listheight*5)
    plt.axis("off") 
    plt.subplots_adjust(bottom=0.2)
    initial_text = "stack {}".format(numStack)
    
    taxbox = plt.axes([0.1, 0.85, 0.6, 0.075])
    stacks[numStack].update({"name":TextBox(taxbox, 'Name', initial=initial_text)})
    axButSav=plt.axes([0.7, 0.85, 0.1, 0.075], facecolor=axcolor)
    stacks[numStack].update({"saver":Button(axButSav, label="SAVE", image=None, color='0.85', hovercolor='0.95')})
    
    axButRem=plt.axes([0.85, 0.85, 0.1, 0.075], facecolor=axcolor)
    stacks[numStack].update({"rem":Button(axButRem, label="DEL", image=None, color='0.85', hovercolor='0.95')})
    
    stacks[numStack]["rem"].on_clicked(Remstack)    
    stacks[numStack]["saver"].on_clicked(Saveline)    
    stacks[numStack]["name"].on_submit(update) 
    
    stacks[numStack].update({"fig":stackfig,"ax":stackax})    
    
    for ind, Filter in enumerate(Filters):
        #axTxt = plt.axes([x_off, y_off + 0.05*(1+ind), 0.08, 0.03],facecolor=axcolor)
        #stacks[numStack]["text"].append(axTxt.text("{}".format(Filter)))
        axButMin=plt.axes([x_off, y_off + y_h*(1+ind), 0.09, 0.03], facecolor=axcolor)
        axButPlus=plt.axes([x_off + x_h, y_off + 0.05*(1+ind), 0.06, 0.03], facecolor=axcolor)
        stacks[numStack]["buttons"].append(Button(axButMin, label="remove [0]", image=None, color='0.85', hovercolor='0.95'))
        stacks[numStack]["buttons"][-1].label.set_x(0.05)
        stacks[numStack]["buttons"][-1].label.set_horizontalalignment('left')
        stacks[numStack]["buttons"].append(Button(axButPlus, label="add  {}".format(Filter), image=None, color='0.85', hovercolor='0.95'))
        stacks[numStack]["buttons"][-1].label.set_x(0.2)
        stacks[numStack]["buttons"][-1].label.set_horizontalalignment('left')
        if verbose:
            print("\n buttons assigned for stack {}, itteration: {} \n {}".format(len(stacks),ind,Filter))
   
    line, = axMain.plot(wavelength_range,recalc(wavelength_range,Filters,stacks[numStack]["coeffs"]),label=stacks[numStack]["name"].text)
    stacks[numStack].update({"line":line})
    
    for ind, button in enumerate(stacks[numStack]["buttons"]):
        i=int(np.floor(ind/2))
        if (ind/2)%1==0:
            button.on_clicked(stacks[numStack]["coeffs"][i].down)
        else:
            button.on_clicked(stacks[numStack]["coeffs"][i].up)
    
    

####    MAIN    ####


goToFilDir()
directory = os.getcwd()


os.chdir(directory)
for filename in os.listdir(directory):
    if filename.endswith(".csv"):
        add_curve_from_file(filename)        

if len(Filters)>1:
    plt.ion()
    figMain, axMain = plt.subplots()
    axMain.set_yscale('log')
    axMain.grid(which='both')
    
    axcolor = "lightgoldenrodyellow"
    axButStack=plt.axes([0.78, 0.94, 0.18, 0.03], facecolor=axcolor)
    butStack = Button(axButStack, label="Add Filter Stack", image=None, color='0.85', hovercolor='0.95')
    axButLog=plt.axes([0.78, 0.9, 0.06, 0.03], facecolor=axcolor)
    butLog = Button(axButLog, label="Log", image=None, color='0.85', hovercolor='0.95')
    axButLin=plt.axes([0.86, 0.9, 0.07, 0.03], facecolor=axcolor)
    butLin = Button(axButLin, label="Linear", image=None, color='0.85', hovercolor='0.95')
    
    butLog.on_clicked(log)
    butLin.on_clicked(lin)
    
    stacks = []         
    addStack()    
    butStack.on_clicked(addStack)

    axMain.legend()
    

elif len(Filters) == 1:
    plt.ion()
    fig, ax = plt.subplots()
    ax.set_yscale('log')
    ax.grid(which='both')
    key = list(Filters)[0]
    if verbose:
        print("Plotting data for {}\n\n WR:{} \n\n TRANS:{}".format(key,wavelength_range,Filters[key]))    
    ax.plot(wavelength_range,Filters[key])
    ax.relim()
    ax.set_ybound(upper=1)
    ax.autoscale_view()
    fig.canvas.draw_idle()


else:
    print("no filters found in {}".format(directory))            